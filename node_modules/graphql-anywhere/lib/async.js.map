{"version":3,"file":"async.js","sources":["../src/graphql.ts","../src/graphql-async.ts"],"sourcesContent":["import {\n  DocumentNode,\n  SelectionSetNode,\n  FieldNode,\n  FragmentDefinitionNode,\n  InlineFragmentNode,\n} from 'graphql';\n\nimport {\n  getMainDefinition,\n  getFragmentDefinitions,\n  createFragmentMap,\n  FragmentMap,\n  DirectiveInfo,\n  shouldInclude,\n  getDirectiveInfoFromField,\n  isField,\n  isInlineFragment,\n  resultKeyNameFromField,\n  argumentsObjectFromField,\n} from 'apollo-utilities';\n\nexport type Resolver = (\n  fieldName: string,\n  rootValue: any,\n  args: any,\n  context: any,\n  info: ExecInfo,\n) => any;\n\nexport type VariableMap = { [name: string]: any };\n\nexport type ResultMapper = (\n  values: { [fieldName: string]: any },\n  rootValue: any,\n) => any;\nexport type FragmentMatcher = (\n  rootValue: any,\n  typeCondition: string,\n  context: any,\n) => boolean;\n\nexport type ExecContext = {\n  fragmentMap: FragmentMap;\n  contextValue: any;\n  variableValues: VariableMap;\n  resultMapper: ResultMapper;\n  resolver: Resolver;\n  fragmentMatcher: FragmentMatcher;\n};\n\nexport type ExecInfo = {\n  isLeaf: boolean;\n  resultKey: string;\n  directives: DirectiveInfo;\n};\n\nexport type ExecOptions = {\n  resultMapper?: ResultMapper;\n  fragmentMatcher?: FragmentMatcher;\n};\n\n/* Based on graphql function from graphql-js:\n *\n * graphql(\n *   schema: GraphQLSchema,\n *   requestString: string,\n *   rootValue?: ?any,\n *   contextValue?: ?any,\n *   variableValues?: ?{[key: string]: any},\n *   operationName?: ?string\n * ): Promise<GraphQLResult>\n *\n * The default export as of graphql-anywhere is sync as of 4.0,\n * but below is an exported alternative that is async.\n * In the 5.0 version, this will be the only export again\n * and it will be async\n * \n */\nexport function graphql(\n  resolver: Resolver,\n  document: DocumentNode,\n  rootValue?: any,\n  contextValue?: any,\n  variableValues?: VariableMap,\n  execOptions: ExecOptions = {},\n) {\n  const mainDefinition = getMainDefinition(document);\n\n  const fragments = getFragmentDefinitions(document);\n  const fragmentMap = createFragmentMap(fragments);\n\n  const resultMapper = execOptions.resultMapper;\n\n  // Default matcher always matches all fragments\n  const fragmentMatcher = execOptions.fragmentMatcher || (() => true);\n\n  const execContext: ExecContext = {\n    fragmentMap,\n    contextValue,\n    variableValues,\n    resultMapper,\n    resolver,\n    fragmentMatcher,\n  };\n\n  return executeSelectionSet(\n    mainDefinition.selectionSet,\n    rootValue,\n    execContext,\n  );\n}\n\nfunction executeSelectionSet(\n  selectionSet: SelectionSetNode,\n  rootValue: any,\n  execContext: ExecContext,\n) {\n  const { fragmentMap, contextValue, variableValues: variables } = execContext;\n\n  const result = {};\n\n  selectionSet.selections.forEach(selection => {\n    if (!shouldInclude(selection, variables)) {\n      // Skip this entirely\n      return;\n    }\n\n    if (isField(selection)) {\n      const fieldResult = executeField(selection, rootValue, execContext);\n\n      const resultFieldKey = resultKeyNameFromField(selection);\n\n      if (fieldResult !== undefined) {\n        if (result[resultFieldKey] === undefined) {\n          result[resultFieldKey] = fieldResult;\n        } else {\n          merge(result[resultFieldKey], fieldResult);\n        }\n      }\n    } else {\n      let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n      if (isInlineFragment(selection)) {\n        fragment = selection;\n      } else {\n        // This is a named fragment\n        fragment = fragmentMap[selection.name.value];\n\n        if (!fragment) {\n          throw new Error(`No fragment named ${selection.name.value}`);\n        }\n      }\n\n      const typeCondition = fragment.typeCondition.name.value;\n\n      if (execContext.fragmentMatcher(rootValue, typeCondition, contextValue)) {\n        const fragmentResult = executeSelectionSet(\n          fragment.selectionSet,\n          rootValue,\n          execContext,\n        );\n\n        merge(result, fragmentResult);\n      }\n    }\n  });\n\n  if (execContext.resultMapper) {\n    return execContext.resultMapper(result, rootValue);\n  }\n\n  return result;\n}\n\nfunction executeField(\n  field: FieldNode,\n  rootValue: any,\n  execContext: ExecContext,\n): any {\n  const { variableValues: variables, contextValue, resolver } = execContext;\n\n  const fieldName = field.name.value;\n  const args = argumentsObjectFromField(field, variables);\n\n  const info: ExecInfo = {\n    isLeaf: !field.selectionSet,\n    resultKey: resultKeyNameFromField(field),\n    directives: getDirectiveInfoFromField(field, variables),\n  };\n\n  const result = resolver(fieldName, rootValue, args, contextValue, info);\n\n  // Handle all scalar types here\n  if (!field.selectionSet) {\n    return result;\n  }\n\n  // From here down, the field has a selection set, which means it's trying to\n  // query a GraphQLObjectType\n  if (result == null) {\n    // Basically any field in a GraphQL response can be null, or missing\n    return result;\n  }\n\n  if (Array.isArray(result)) {\n    return executeSubSelectedArray(field, result, execContext);\n  }\n\n  // Returned value is an object, and the query has a sub-selection. Recurse.\n  return executeSelectionSet(field.selectionSet, result, execContext);\n}\n\nfunction executeSubSelectedArray(field, result, execContext) {\n  return result.map(item => {\n    // null value in array\n    if (item === null) {\n      return null;\n    }\n\n    // This is a nested array, recurse\n    if (Array.isArray(item)) {\n      return executeSubSelectedArray(field, item, execContext);\n    }\n\n    // This is an object, run the selection set on it\n    return executeSelectionSet(field.selectionSet, item, execContext);\n  });\n}\n\nexport function merge(dest, src) {\n  if (src === null || typeof src !== 'object') {\n    // These types just override whatever was in dest\n    return src;\n  }\n\n  // Merge sub-objects\n  Object.keys(dest).forEach(destKey => {\n    if (src.hasOwnProperty(destKey)) {\n      merge(dest[destKey], src[destKey]);\n    }\n  });\n\n  // Add props only on src\n  Object.keys(src).forEach(srcKey => {\n    if (!dest.hasOwnProperty(srcKey)) {\n      dest[srcKey] = src[srcKey];\n    }\n  });\n}\n","import {\n  DocumentNode,\n  SelectionSetNode,\n  FieldNode,\n  FragmentDefinitionNode,\n  InlineFragmentNode,\n} from 'graphql';\n\nimport {\n  getMainDefinition,\n  getFragmentDefinitions,\n  createFragmentMap,\n  shouldInclude,\n  getDirectiveInfoFromField,\n  isField,\n  isInlineFragment,\n  resultKeyNameFromField,\n  argumentsObjectFromField,\n} from 'apollo-utilities';\n\nimport {\n  merge,\n  Resolver,\n  VariableMap,\n  ExecContext,\n  ExecInfo,\n  ExecOptions,\n} from './graphql';\n\n/* Based on graphql function from graphql-js:\n *\n * graphql(\n *   schema: GraphQLSchema,\n *   requestString: string,\n *   rootValue?: ?any,\n *   contextValue?: ?any,\n *   variableValues?: ?{[key: string]: any},\n *   operationName?: ?string\n * ): Promise<GraphQLResult>\n *\n * The default export as of graphql-anywhere is sync as of 4.0,\n * but below is an exported alternative that is async.\n * In the 5.0 version, this will be the only export again\n * and it will be async\n * \n */\nexport function graphql(\n  resolver: Resolver,\n  document: DocumentNode,\n  rootValue?: any,\n  contextValue?: any,\n  variableValues?: VariableMap,\n  execOptions: ExecOptions = {},\n): Promise<null | Object> {\n  const mainDefinition = getMainDefinition(document);\n\n  const fragments = getFragmentDefinitions(document);\n  const fragmentMap = createFragmentMap(fragments);\n\n  const resultMapper = execOptions.resultMapper;\n\n  // Default matcher always matches all fragments\n  const fragmentMatcher = execOptions.fragmentMatcher || (() => true);\n\n  const execContext: ExecContext = {\n    fragmentMap,\n    contextValue,\n    variableValues,\n    resultMapper,\n    resolver,\n    fragmentMatcher,\n  };\n\n  return executeSelectionSet(\n    mainDefinition.selectionSet,\n    rootValue,\n    execContext,\n  );\n}\n\nasync function executeSelectionSet(\n  selectionSet: SelectionSetNode,\n  rootValue: any,\n  execContext: ExecContext,\n) {\n  const { fragmentMap, contextValue, variableValues: variables } = execContext;\n\n  const result = {};\n\n  const execute = async selection => {\n    if (!shouldInclude(selection, variables)) {\n      // Skip this entirely\n      return;\n    }\n\n    if (isField(selection)) {\n      const fieldResult = await executeField(selection, rootValue, execContext);\n\n      const resultFieldKey = resultKeyNameFromField(selection);\n\n      if (fieldResult !== undefined) {\n        if (result[resultFieldKey] === undefined) {\n          result[resultFieldKey] = fieldResult;\n        } else {\n          merge(result[resultFieldKey], fieldResult);\n        }\n      }\n\n      return;\n    }\n\n    let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n    if (isInlineFragment(selection)) {\n      fragment = selection;\n    } else {\n      // This is a named fragment\n      fragment = fragmentMap[selection.name.value];\n\n      if (!fragment) {\n        throw new Error(`No fragment named ${selection.name.value}`);\n      }\n    }\n\n    const typeCondition = fragment.typeCondition.name.value;\n\n    if (execContext.fragmentMatcher(rootValue, typeCondition, contextValue)) {\n      const fragmentResult = await executeSelectionSet(\n        fragment.selectionSet,\n        rootValue,\n        execContext,\n      );\n\n      merge(result, fragmentResult);\n    }\n  };\n\n  await Promise.all(selectionSet.selections.map(execute));\n\n  if (execContext.resultMapper) {\n    return execContext.resultMapper(result, rootValue);\n  }\n\n  return result;\n}\n\nasync function executeField(\n  field: FieldNode,\n  rootValue: any,\n  execContext: ExecContext,\n): Promise<null | Object> {\n  const { variableValues: variables, contextValue, resolver } = execContext;\n\n  const fieldName = field.name.value;\n  const args = argumentsObjectFromField(field, variables);\n\n  const info: ExecInfo = {\n    isLeaf: !field.selectionSet,\n    resultKey: resultKeyNameFromField(field),\n    directives: getDirectiveInfoFromField(field, variables),\n  };\n\n  const result = await resolver(fieldName, rootValue, args, contextValue, info);\n\n  // Handle all scalar types here\n  if (!field.selectionSet) {\n    return result;\n  }\n\n  // From here down, the field has a selection set, which means it's trying to\n  // query a GraphQLObjectType\n  if (result == null) {\n    // Basically any field in a GraphQL response can be null, or missing\n    return result;\n  }\n\n  if (Array.isArray(result)) {\n    return executeSubSelectedArray(field, result, execContext);\n  }\n\n  // Returned value is an object, and the query has a sub-selection. Recurse.\n  return executeSelectionSet(field.selectionSet, result, execContext);\n}\n\nfunction executeSubSelectedArray(field, result, execContext) {\n  return Promise.all(\n    result.map(item => {\n      // null value in array\n      if (item === null) {\n        return null;\n      }\n\n      // This is a nested array, recurse\n      if (Array.isArray(item)) {\n        return executeSubSelectedArray(field, item, execContext);\n      }\n\n      // This is an object, run the selection set on it\n      return executeSelectionSet(field.selectionSet, item, execContext);\n    }),\n  );\n}\n"],"names":["getMainDefinition","getFragmentDefinitions","createFragmentMap","executeSelectionSet","shouldInclude","isField","executeField","resultKeyNameFromField","isInlineFragment","argumentsObjectFromField","getDirectiveInfoFromField","executeSubSelectedArray"],"mappings":"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"}